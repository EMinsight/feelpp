== Ray tracing algorithm based on NanoFlann's kd-tree implementation

= Nanoflann

_Nanoflann_ is a header only library for building Kd-trees and performing fast nearest-neighbour searches.
The GitHub page of the project is https://github.com/jlblancoc/nanoflann and its Doxygen documentation can be found in https://jlblancoc.github.io/nanoflann/.

In the kd-tree proposed in Nanoflann, each node is defined by a structure containing:

* For a leaf node : the first (_left_) and last element (_right_) of the list of indices of points belonging to the leaf
* For a non-leaf node : the integer identifying the splitting direction (_divfeat_), the maximal value in that direction of the left child's bounding box (_divlow_) and the minimal value in that direction of the right child's bounding box (_divhigh_).

The ray tracing algorithm aims at finding the leaf/leaves that the ray intersects. 
First of all, check if the ray intersects the bounding box of the whole kd-tree.
If it's the case, find the point of intersection with the bounding box that is closer to the origin of the ray. 
The algorithm then checks recursively the nodes for intersection until a leaf is found. Few important aspects must be noticed:

* since each non-leaf node is defined by the pair (_divlow_,_divhigh_) in the _divfeat_ direction, and $_divlow_ < _divhigh_$, it can happen that the _divfeat_-th coordinate of the intersection point is strictly contained in the interval [_divlow_,_divhigh_]. In this case, one can't choose the left leaf over the right leaf to continue the traversal of the tree, and must check both. For this reason, in the code a vector of two nodes is handled when the previous condition holds. 
* the indices returned by the leaf nodes must be used to access vector _vAcc_, which contains the set of labels to the points in the kd-tree.
* the points in the leaves are not necessarily all the closest ones to the intersection point, as splitting at some point along one direction might exclude some of them.